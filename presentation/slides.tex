\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{url}

\usetheme{Copenhagen}
\usecolortheme{default}

\title{The advanced return-into-lib(c) exploits}
\subtitle{\url{http://phrack.org/issues/58/4.html}}
\author{Anders Kiel Hovgaard \and Daniel Gavin \and Rúni Klein Hansen}
\institute{Department of Computer Science, University of Copenhagen}
\date{May 22, 2015}

\begin{document}

\frame{\titlepage}

\section{Classical return-into-libc} % Anders

\begin{frame}[fragile]
  \frametitle{Classical return-into-libc}

  A method commonly used to circumvent non-executable stack by returning to a
  dynamic library instead of returning to code located on the stack.

  \begin{verbatim}
    |         ...        |  arg_2
    |--------------------|
    | addr. of "/bin/sh" |  arg_1
    |--------------------|
    |  dummy ret. addr.  |  dummy_int32
    |--------------------|
    | addr. of system()  |  funcion_in_lib
    |--------------------|
    |     0x41414141     |  buffer fill-up
    |     0x41414141     |
    |         ...        |
    |--------------------|
  \end{verbatim}
\end{frame}


\section{Chaining return-into-libc calls} % Anders

\subsection{Problems with the classical approach}

\begin{frame}

\end{frame}


\section{PaX features}  % Rúni





\section{The dynamic linker's dl-resolve() function}  % Daniel

\begin{frame}[fragile]
\frametitle{Procedure linkage table(PLT)}

 \begin{itemize}
    \item PLT's purpose is to provide a level of indirection when calling external library functions.
    \item PLT is lazy binding.
    \item PLT ensures that code remains read-only, and that is because all external functions are not directly called from code.
    \item PLT is in the code segment, and the addresses that PLT modifies are in the global offset table(GOT).
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Procedure linkage table entry}
A typical PLT entry for elf32-i386.
	\begin{verbatim}
	080484c0 <mmap@plt>:
	 80484c0:	ff 25 30 a0 04 08 jmp    DWORD PTR ds:0x804a030
	 80484c6:	68 48 00 00 00    push   0x48
	 80484cb:	e9 50 ff ff ff    jmp    8048420 <_init+0x24>
	\end{verbatim}


\end{frame}

\begin{frame}[fragile]
\frametitle{elf32 types}

	\footnotesize 
	\begin{verbatim}
	
	typedef uint32_t Elf32_Addr;
	typedef uint32_t Elf32_Word;
	
	typedef struct
	{
	  Elf32_Addr    r_offset;  /* Address */
	  Elf32_Word    r_info;    /* Relocation type and symbol index */
	} Elf32_Rel;
	
	/* How to extract and insert information held in the r_info field.*/
	#define ELF32_R_SYM(val)                ((val) >> 8)
	#define ELF32_R_TYPE(val)               ((val) & 0xff)
	\end{verbatim}
	\normalsize

\end{frame}

\begin{frame}[fragile]
\frametitle{elf32 types}

	\footnotesize 
	\begin{verbatim}
	
	typedef struct
	{
	  Elf32_Word    st_name;   /* Symbol name (string tbl index) */
	  Elf32_Addr    st_value;  /* Symbol value */
	  Elf32_Word    st_size;   /* Symbol size */
	  unsigned char st_info;   /* Symbol type and binding */
	  unsigned char st_other;  /* Symbol visibility under glibc>=2.2 */
	  Elf32_Section st_shndx;  /* Section index */
	} Elf32_Sym;
	
	The fields st_size, st_info and st_shndx are not used during symbol
	resolution.
	\end{verbatim}
	\normalsize

\end{frame}

\begin{frame}[fragile]
\frametitle{elf32 structure}

	\scriptsize   
	\begin{verbatim}
	pcs2015@pcs2015:~/share/ret2libc/demo$ readelf -d vuln
	
	Dynamic section at offset 0x80c contains 24 entries:
	  Tag        Type                         Name/Value
	 ... more stuff ...
	 0x00000005 (STRTAB)    0x804824c string table (type char *)
	 ...
	 0x00000006 (SYMTAB)    0x80481ac symbol table (type Elf32_Sym*)
	 ...
	 0x00000017 (JMPREL)    0x80482f0 table of relocation entries 
	                                  related to PLT (type Elf32_Rel*)
	 ...
	 0x6ffffff0 (VERSYM)    0x80482b2 array of version table indices  
	                                                   (type uint16_t*)
	 ... 
	\end{verbatim}
	\normalsize

\end{frame}

\begin{frame}[fragile]
\frametitle{dl-resolve() algorithm}

This is the simplified explanation of how the algorithm works.

 \begin{itemize}
    \item  Calculate some\_func's relocation entry
    \\
    Elf32\_Rel * reloc = JMPREL + reloc\_offset.
    
    \item Calculate some\_func's symtab entry
    \\
    Elf32\_Sym * sym = \&SYMTAB[ ELF32\_R\_SYM (reloc $->$ r\_info) ];	
  	
  	\item Sanity check 
  	\\
  	assert(ELF32\_R\_TYPE(reloc$->$r\_info)==R\_386\_JMP\_SLOT);
  \end{itemize}

\end{frame}


\begin{frame}[fragile]
\frametitle{dl-resolve() algorithm}
 \begin{itemize}
    \item Check if sym$->$st\_other \& 3 == 0, then algorithm presumes that the symbol has not been resolved before.
    
    \item If symbol versioning is enabled, determine the version table index, and use it to find version information.
    \\
    uint16\_t ndx = VERSYM[ ELF32\_R\_SYM (reloc$->$r\_info) ]; 
    \\
    const struct r\_found\_version *version =\&l$->$l\_versions[ndx];
    
    \item Determine function name (an asciiz string)
    \\
    name = STRTAB + sym$->$st\_name;
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{dl-runtime-resolve() algorithm}
 \begin{itemize}
    \item Algorithm has enough information to retrieve the address for the function, and caches it in reloc$->$r\_offset and sym$->$st\_value.
    
    \item The GOT value for the function address is modified.
    
    \item The retrieved function address is called.
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Exploiting dl-runtime-resolve()}
 
\begin{itemize}
\item How can we exploit dl-runtime-resolve()?

\item We could prepare a appropriate Elf32\_Sym and Elf32\_Rel, and calculate the reloc\_offset to fit with where Elf32\_Rel is placed.
 
\item We would then call .plt start with the
correct reloc\_offset.
\item The exploit would also require some data copying function to be in PLT(strcpy, sprintf, etc).

\end{itemize}
 
\scriptsize   
\begin{verbatim}
|----------------------------------------------------------------------|
| buffer_overflow | .plt start | reloc_offset | ret_addr | arg1 | .... |  
|----------------------------------------------------------------------|
\end{verbatim}
\normalsize


\end{frame}

\begin{frame}[fragile]
\frametitle{Exploiting dl-runtime-resolve()}
We need to ensure that the structures are placed correctly in memory.
\begin{verbatim}
Elf32_Rel reloc.
Elf32_Sym sym.
unsigned short verind (which should be 0).

reloc is at address JMPREL+reloc_offset.

real_index = ELF32_R_SYM (reloc->r_info)

sym is at address SYMTAB+real_index*sizeof(Elf32_Sym)
verind is at address VERSYM+real_index*sizeof(short)
function_name is at address STRTAB + sym->st_name
\end{verbatim}

\end{frame}

\section{Demo}
\frametitle

\begin{frame}
Demo time!
\end{frame}

\end{document}
